# game.py
# This is a complete, self-contained text-based RPG.
# All code, narrative, and logic were generated by an AI as per the user's request.

import random
import time
import sys

# --- Helper Functions ---

def slow_print(text, delay=0.03):
    """
    Prints text to the console one character at a time for a typewriter effect.
    """
    for char in text:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(delay)
    print()

def get_input(prompt="> "):
    """
    Gets user input and standardizes it.
    """
    return input(prompt).strip().lower()

def roll_d20():
    """
    Simulates rolling a 20-sided die.
    """
    return random.randint(1, 20)

# --- Game Classes ---

class Item:
    """
    Represents an item in the game (e.g., potion, weapon, quest item).
    """
    def __init__(self, name, description, item_type="general", effect=None, value=0):
        self.name = name
        self.description = description
        self.item_type = item_type  # 'potion', 'weapon', 'key'
        self.effect = effect        # e.g., 'heal'
        self.value = value          # e.g., health restored, damage boost

    def __str__(self):
        return self.name

class Player:
    """
    Represents the player character.
    """
    def __init__(self, name):
        self.name = name
        self.char_class = ""
        self.health = 0
        self.max_health = 0
        self.stats = {"strength": 0, "agility": 0, "magic": 0}
        self.inventory = []
        self.location = 'start'
        self.weapon_bonus = 0
        self.flags = {} # For tracking story choices

    def is_alive(self):
        return self.health > 0

    def add_item(self, item):
        """
        Adds an item to the player's inventory.
        """
        self.inventory.append(item)
        slow_print(f"You picked up: {item.name}.")
        if item.item_type == 'weapon':
            self.weapon_bonus = item.value

    def show_inventory(self):
        """
        Displays the player's inventory.
        """
        if not self.inventory:
            slow_print("Your inventory is empty.")
            return

        slow_print("You have:")
        for item in self.inventory:
            slow_print(f"* {item.name}: {item.description}")

    def use_item(self, item_name):
        """
        Uses an item from the inventory.
        """
        item_to_use = None
        for item in self.inventory:
            if item.name.lower() == item_name:
                item_to_use = item
                break
        
        if not item_to_use:
            slow_print(f"You don't have a '{item_name}'.")
            return

        if item_to_use.item_type == 'potion':
            if item_to_use.effect == 'heal':
                self.health += item_to_use.value
                if self.health > self.max_health:
                    self.health = self.max_health
                slow_print(f"You use the {item.name} and restore {item.value} health.")
                slow_print(f"You now have {self.health}/{self.max_health} health.")
                self.inventory.remove(item_to_use)
            else:
                slow_print(f"You can't use the {item.name} right now.")
        else:
            slow_print(f"You can't 'use' the {item.name} in this way.")

    def get_attack_roll(self):
        """
        Calculates the player's attack roll based on their class.
        """
        roll = roll_d20()
        modifier = 0
        if self.char_class == "Warrior":
            modifier = self.stats["strength"]
        elif self.char_class == "Rogue":
            modifier = self.stats["agility"]
        elif self.char_class == "Mage":
            modifier = self.stats["magic"]
        
        return roll + modifier + self.weapon_bonus

class Enemy:
    """
    Represents an enemy.
    """
    def __init__(self, name, description, health, attack_damage, defense):
        self.name = name
        self.description = description
        self.health = health
        self.max_health = health
        self.attack_damage = attack_damage
        self.defense = defense # Target number for player to hit

    def is_alive(self):
        return self.health > 0

    def take_damage(self, amount):
        self.health -= amount
        if self.health < 0:
            self.health = 0
        slow_print(f"The {self.name} takes {amount} damage. It has {self.health} health left.")

# --- Main Game Class ---

class Game:
    """
    Manages the game state, locations, items, and main loop.
    """
    def __init__(self):
        self.player = None
        self.locations = {}
        self.items = {}
        self.enemies = {}
        self.game_over = False
        self._setup_game()

    def _setup_game(self):
        """
        Initializes all game data (items, enemies, locations).
        """
        # --- Define Items ---
        self.items["potion"] = Item("Healing Potion", "Restores 20 health.", "potion", "heal", 20)
        self.items["rusty_sword"] = Item("Rusty Sword", "A worn-out sword. +1 attack.", "weapon", "attack", 1)
        self.items["shadow_cloak"] = Item("Shadow Cloak", "A cloak made of shadows. +1 agility.", "armor", "stat", 1)
        self.items["glowing_staff"] = Item("Glowing Staff", "A staff humming with energy. +1 magic.", "weapon", "attack", 1)
        self.items["ghostly_amulet"] = Item("Ghostly Amulet", "A cold amulet from the forest spirit.", "key")
        self.items["bandit_key"] = Item("Bandit Key", "A crude iron key. Seems to unlock a chest.", "key")
        self.items["kings_seal"] = Item("King's Seal", "The royal seal of the castle.", "key")

        # --- Define Enemies ---
        self.enemies["goblin"] = Enemy("Goblin", "A small, vicious creature.", 30, 5, 12)
        self.enemies["bandit"] = Enemy("Bandit", "A desperate outlaw with a keen knife.", 45, 8, 13)
        self.enemies["shadow_beast"] = Enemy("Shadow Beast", "A creature of pure darkness from the Cursed Keep.", 60, 12, 14)
        self.enemies["dragon_king"] = Enemy("Cursed Dragon King", "A terrifying, pained beast of scales and shadow.", 100, 15, 16)

        # --- Define Locations ---
        self.locations = {
            'start': {
                'description': "You stand at a crossroads. A dark forest looms to the 'north'. A rocky pass, known to be a 'bandit' lair, is to the 'east'.",
                'exits': {'north': 'forest_1', 'east': 'bandit_lair_1'},
                'items': [],
                'enemies': [],
            },
            'forest_1': {
                'description': "You enter the Whispering Woods. The trees are thick and block out the sun. You hear a goblin shuffling nearby. You can 'go deeper' into the forest or 'go back' to the crossroads.",
                'exits': {'deeper': 'forest_2', 'back': 'start'},
                'items': [self.items["potion"]],
                'enemies': [self.enemies["goblin"]],
            },
            'forest_2': {
                'description': "Deeper in the woods, you find a clearing. A 'ghostly figure' hovers over a small grave. It seems to be weeping. You can 'go back' or 'approach' the figure.",
                'exits': {'back': 'forest_1', 'approach': 'forest_ghost'},
                'items': [],
                'enemies': [],
            },
            'forest_ghost': {
                'description': "You approach the ghost. It turns, its face a mask of sorrow. 'My amulet... stolen... buried with the king...' it whispers. 'Please... free him... from the curse.' It offers you the Ghostly Amulet. You can 'take' the amulet or 'attack' the ghost. You can also 'leave'.",
                'exits': {'leave': 'forest_2'},
                'items': [self.items["ghostly_amulet"]],
                'enemies': [],
            },
            'bandit_lair_1': {
                'description': "You sneak into the rocky pass. A 'bandit' stands guard, warming his hands over a fire. You can try to 'attack' him or 'sneak' past.",
                'exits': {'attack': 'bandit_lair_combat', 'sneak': 'bandit_lair_sneak'},
                'items': [],
                'enemies': [self.enemies["bandit"]],
            },
            'bandit_lair_combat': {
                'description': "You failed to sneak past! The bandit draws his knife!",
                'exits': {'win': 'bandit_lair_2'},
                'items': [],
                'enemies': [self.enemies["bandit"]],
            },
            'bandit_lair_sneak': {
                'description': "You attempt to sneak...",
                'exits': {}, # Handled by logic
            },
            'bandit_lair_2': {
                'description': "You are inside the bandit camp. It's mostly deserted, but a crude chest sits in the corner. A path leads 'north' towards the castle.",
                'exits': {'north': 'castle_gate'},
                'items': [self.items["bandit_key"]], # Key is on the bandit, added on win
                'enemies': [],
            },
            'castle_gate': {
                'description': "You've arrived at the Cursed Keep. The massive gate is barred. A 'shadowy beast' patrols the entrance. You can 'go back' to the path or 'attack' the beast to find a way in.",
                'exits': {'back': 'start'}, # Simplifies nav
                'items': [],
                'enemies': [self.enemies["shadow_beast"]],
            },
            'castle_throne_room': {
                'description': "You enter the throne room. On the throne slumps a monstrous figure, half-man, half-dragon, chained by dark energy. This is the 'Cursed Dragon King'. He roars in pain and rage. 'RELEASE ME!' he bellows.",
                'exits': {},
                'items': [],
                'enemies': [self.enemies["dragon_king"]],
            },
        }

    def start_game(self):
        """
        Begins the game.
        """
        self.character_creation()
        self.main_loop()

    def character_creation(self):
        """
        Guides the player through creating their character.
        """
        slow_print("Welcome, adventurer, to 'The Amulet of Ages'!")
        name = get_input("What is your name? \n> ")
        self.player = Player(name)
        
        slow_print(f"Welcome, {self.player.name}. You must choose your class:")
        slow_print("1. Warrior: (Str: 14, Agi: 10, Mag: 8) - Master of arms.")
        slow_print("2. Rogue: (Str: 10, Agi: 14, Mag: 8) - Master of stealth.")
        slow_print("3. Mage: (Str: 8, Agi: 10, Mag: 14) - Master of arcane arts.")

        while self.player.char_class == "":
            choice = get_input("Choose (1, 2, or 3): \n> ")
            if choice == '1':
                self.player.char_class = "Warrior"
                self.player.stats = {"strength": 4, "agility": 2, "magic": 0} # Modifiers
                self.player.health = 120
                self.player.max_health = 120
                self.player.add_item(self.items["rusty_sword"])
            elif choice == '2':
                self.player.char_class = "Rogue"
                self.player.stats = {"strength": 2, "agility": 4, "magic": 0}
                self.player.health = 100
                self.player.max_health = 100
                self.player.add_item(self.items["shadow_cloak"])
            elif choice == '3':
                self.player.char_class = "Mage"
                self.player.stats = {"strength": 0, "agility": 2, "magic": 4}
                self.player.health = 80
                self.player.max_health = 80
                self.player.add_item(self.items["glowing_staff"])
            else:
                slow_print("Invalid choice. Please enter 1, 2, or 3.")

        slow_print(f"You are a {self.player.char_class}!")
        slow_print("Your adventure begins...")
        time.sleep(1)

    def main_loop(self):
        """
        The main game loop that processes player input.
        """
        while self.player.is_alive() and not self.game_over:
            current_location = self.locations.get(self.player.location)
            if not current_location:
                slow_print("Error: You are in an unknown location. Resetting to start.")
                self.player.location = 'start'
                current_location = self.locations['start']

            self.show_location(current_location)
            
            # Check for auto-combat locations
            if self.player.location == 'bandit_lair_combat':
                self.start_combat(self.enemies["bandit"], 'win', 'bandit_lair_2')
                continue # Skip to next loop iteration after combat
            
            self.handle_input(current_location)
            
            if not self.player.is_alive():
                self.handle_game_over("death")
                break

    def show_location(self, location):
        """
        Displays the description and contents of the current location.
        """
        slow_print("\n" + "=" * 30)
        slow_print(location['description'])
        
        if location['items']:
            slow_print("You see the following items:")
            for item in location['items']:
                slow_print(f"* {item.name}")
        
        if location['enemies']:
            # Check if enemy is still alive (by checking its master definition)
            # This is a simple implementation. A better one would instance enemies.
            # For this game, we'll assume enemies reset or are one-time.
            # Let's check for a 'defeated' flag.
            for enemy in location['enemies']:
                if enemy.name not in self.player.flags.get('defeated', []):
                    slow_print(f"A hostile {enemy.name} is here!")
        
        slow_print("=" * 30)

    def handle_input(self, location):
        """
        Parses and acts on player commands.
        """
        command = get_input()
        parts = command.split()
        if not parts:
            slow_print("You must do something.")
            return

        action = parts[0]
        target = " ".join(parts[1:]) if len(parts) > 1 else ""

        # --- Standard Commands ---
        if action == "quit":
            slow_print("You lay down your arms and return home. The quest is not for you.")
            self.game_over = True
        elif action == "help":
            self.show_help()
        elif action == "inventory" or action == "i":
            self.player.show_inventory()
        elif action == "look" or action == "l":
            # Just let the loop re-print the description
            pass
        
        # --- Movement Commands ---
        elif action == "go":
            if target in location['exits']:
                self.player.location = location['exits'][target]
            else:
                slow_print(f"You can't go '{target}'.")

        # --- Item Commands ---
        elif action == "take":
            item_to_take = None
            for item in location['items']:
                if item.name.lower() == target:
                    item_to_take = item
                    break
            
            if item_to_take:
                self.player.add_item(item_to_take)
                location['items'].remove(item_to_take)
            else:
                slow_print(f"There is no '{target}' here to take.")
        
        elif action == "use":
            self.player.use_item(target)

        # --- Context-Specific Actions ---
        elif self.player.location == 'forest_1' and action == 'attack' and target == 'goblin':
            self.start_combat(self.enemies["goblin"], 'win', self.player.location)
        
        elif self.player.location == 'forest_2' and action == 'approach':
            self.player.location = 'forest_ghost'
        
        elif self.player.location == 'forest_ghost' and action == 'take' and target == 'amulet':
            if self.items["ghostly_amulet"] in location['items']:
                self.player.add_item(self.items["ghostly_amulet"])
                location['items'].remove(self.items["ghostly_amulet"])
                self.player.flags['helped_ghost'] = True
                slow_print("The ghost nods thankfully and fades away.")
                self.player.location = 'forest_2'
            else:
                slow_print("You already took the amulet.")

        elif self.player.location == 'bandit_lair_1' and action == 'attack':
            self.player.location = 'bandit_lair_combat'
            
        elif self.player.location == 'bandit_lair_1' and action == 'sneak':
            self.handle_sneak()
        
        elif self.player.location == 'castle_gate' and action == 'attack':
            self.start_combat(self.enemies["shadow_beast"], 'win', 'castle_throne_room')

        elif self.player.location == 'castle_throne_room' and action == 'attack':
            self.start_combat(self.enemies["dragon_king"], 'win', 'ending_tyrant')

        elif self.player.location == 'castle_throne_room' and action == 'use' and target == 'ghostly amulet':
            if any(item.name == "Ghostly Amulet" for item in self.player.inventory):
                self.handle_game_over("peace")
            else:
                slow_print("You don't have that item.")
        
        # --- Default/Error ---
        else:
            slow_print("You can't do that right now.")


    def handle_sneak(self):
        """
        Logic for the 'sneak' action in the bandit lair.
        """
        slow_print("You try to sneak past the bandit...")
        time.sleep(1)
        roll = roll_d20() + self.player.stats["agility"]
        
        if roll > 15:
            slow_print("Success! You slip past him unseen.")
            self.player.location = 'bandit_lair_2'
        else:
            slow_print("You tripped on a loose stone! The bandit spots you!")
            self.player.location = 'bandit_lair_combat'

    def show_help(self):
        """
        Displays a list of common commands.
        """
        slow_print("--- Basic Commands ---")
        slow_print("go [direction]: Move to a new area (e.g., 'go north').")
        slow_print("look: Examine your surroundings.")
        slow_print("take [item]: Pick up an item.")
        slow_print("use [item]: Use an item from your inventory.")
        slow_print("inventory (i): Check your inventory.")
        slow_print("attack [enemy]: Start combat.")
        slow_print("help: Show this message.")
        slow_print("quit: Exit the game.")
        slow_print("--- Combat Commands ---")
        slow_print("attack: Perform a physical attack.")
        slow_print("defend: Reduce incoming damage for one turn.")
        slow_print("magic: Use a magic spell (Mage only).")
        slow_print("use [potion]: Use a potion on your turn.")

    def start_combat(self, enemy_base, win_state, win_location):
        """
        Manages the turn-based combat loop.
        """
        # Create an instance of the enemy for this fight
        enemy = Enemy(enemy_base.name, enemy_base.description, enemy_base.health, enemy_base.attack_damage, enemy_base.defense)
        
        slow_print(f"\n--- COMBAT START ---")
        slow_print(f"You are fighting a {enemy.name}!")

        turn = 1
        defending = False

        while self.player.is_alive() and enemy.is_alive():
            slow_print(f"\n--- Turn {turn} ---")
            slow_print(f"{self.player.name}: {self.player.health}/{self.player.max_health} HP")
            slow_print(f"{enemy.name}: {enemy.health}/{enemy.max_health} HP")
            
            action = get_input("Combat (attack, defend, magic, use [item]): \n> ")
            
            # --- Player Turn ---
            if action == "attack":
                defending = False
                roll = self.player.get_attack_roll()
                slow_print(f"You roll a {roll} (d20 + modifiers) to attack.")
                if roll >= enemy.defense:
                    damage = random.randint(4, 8) + self.player.stats["strength"] + self.player.weapon_bonus
                    slow_print(f"You hit the {enemy.name} for {damage} damage!")
                    enemy.take_damage(damage)
                else:
                    slow_print(f"You miss the {enemy.name}!")
            
            elif action == "defend":
                defending = True
                slow_print("You brace yourself for an attack, increasing your defense.")
            
            elif action == "magic":
                defending = False
                if self.player.char_class == "Mage":
                    roll = self.player.get_attack_roll() # Uses magic stat
                    if roll >= enemy.defense - 2: # Magic is easier to hit with
                        damage = random.randint(8, 15) + self.player.stats["magic"]
                        slow_print(f"Your magic bolt strikes the {enemy.name} for {damage} damage!")
                        enemy.take_damage(damage)
                    else:
                        slow_print("Your spell fizzles and misses!")
                else:
                    slow_print("You have no magic to cast!")

            elif action.startswith("use"):
                defending = False
                item_name = " ".join(action.split()[1:])
                self.player.use_item(item_name) # 'use_item' handles its own logic
            
            else:
                slow_print("Invalid combat command. You hesitate.")

            # --- Enemy Turn ---
            if enemy.is_alive():
                slow_print(f"The {enemy.name} attacks!")
                time.sleep(1)
                enemy_roll = roll_d20()
                
                # Player defense logic
                player_defense = 10 + self.player.stats["agility"]
                if defending:
                    player_defense += 5
                
                if enemy_roll >= player_defense:
                    damage = enemy.attack_damage
                    if defending:
                        damage = max(1, damage // 2) # Halve damage, min 1
                    
                    slow_print(f"The {enemy.name} hits you for {damage} damage!")
                    self.player.health -= damage
                else:
                    slow_print(f"The {enemy.name} misses you!")
            
            if self.player.health <= 0:
                self.handle_game_over("death")
                return

            turn += 1

        # --- Combat End ---
        if enemy.is_alive() == False:
            slow_print(f"You have defeated the {enemy.name}!")
            self.player.flags.setdefault('defeated', []).append(enemy.name)
            
            # Grant rewards
            if enemy.name == "Bandit":
                self.player.add_item(self.items["bandit_key"])
            if enemy.name == "Shadow Beast":
                self.player.add_item(self.items["kings_seal"])
            
            if win_state == 'win':
                self.player.location = win_location
            elif win_state == 'ending':
                self.handle_game_over(win_location)

    def handle_game_over(self, ending_type):
        """
        Handles the different game endings.
        """
        self.game_over = True
        slow_print("\n" + "*" * 40)
        slow_print(" " * 15 + "THE END" + " " * 15)
        slow_print("*" * 40)

        if ending_type == "death":
            slow_print("Your wounds are too great. You collapse.")
            slow_print("The darkness spreads, and your name is lost to time.")
            slow_print("\n--- ENDING: The Forgotten Hero ---")
        
        elif ending_type == "ending_tyrant":
            slow_print("With a final, brutal blow, you strike down the Dragon King.")
            slow_print("The curse... doesn't break. The dark energy, now free from its vessel,")
            slow_print("corrupts you, filling the void. You take the throne, your heart")
            slow_print("as cold and monstrous as the beast you just slew.")
            slow_print("\n--- ENDING: The Tyrant's Throne ---")

        elif ending_type == "peace":
            slow_print("As the king lunges, you hold up the Ghostly Amulet.")
            slow_print("It pulses with a soft, cold light. The king stops, his")
            slow_print("dragon-like features receding. He sees the amulet and whispers... 'My love...'")
            slow_print("The curse breaks. The dark energy dissipates. The king, now human,")
            slow_print("slumps on the throne, weeping. 'You... you freed me. Thank you.'")
            slow_print("You have saved the kingdom not with a sword, but with kindness.")
            slow_print("\n--- ENDING: The Peacemaker ---")

# --- Main execution ---
if __name__ == "__main__":
    try:
        game = Game()
        game.start_game()
    except (KeyboardInterrupt, EOFError):
        slow_print("\n\nGame interrupted. Goodbye.")
        sys.exit(0)
